#ifndef POINT_H
#define POINT_H

#define POINT_DIMENSION_CONSTRUCTOR_FAIL "Trying to construct a point with an amount of parameters not matching dimension"
#define POINT_DIMENSION_GETCOORD_FAIL "Trying to get a coordinate which does not exist for the vector's dimension"

//#define USE_CUSTOM_COPY_CONSTRUCTOR

#include <iostream>

#include "utils\common.h"
#include "math\deprecated\point3d.h" // for backwards compatibility with Point3d
#include "math\deprecated\point2d.h" // for backwards compatibility with Point2d<T>

// TODO: starting from C++11 we could implement these generic constructors in a much more easier and readable way either by using parameter packs or initializer_list
// TODO: create a test suite module for the Vector class

#ifdef USE_DEPRECATED_POINT
namespace yorumathpoint = yoru::math::deprecated; // define this to either yoru::math to use the generic Point<T,D> class or to yoru::math::deprecated to use the old Point3d and Point2d<T> classes
#else
namespace yorumathpoint = yoru::math;
#endif

namespace yoru {
namespace math {

	namespace deprecated 
	{
		class Vector3d;
	}

	//////////////
	// Templates forward declarations

	template <typename T, size_t D>
	class Point;

	template <typename T, size_t D>
	class Vector;

	template <typename T, size_t D>
	bool operator==(const Point<T,D>& p1, const Point<T,D>& p2);

	template <typename T, size_t D>
	Vector<T,D> operator-(const Point<T,D>& p1, const Point<T,D>& p2);

	template <typename T, size_t D>
	Point<T,D> operator+(const Point<T,D>& p, const Vector<T,D>& v);

	template <typename T, size_t D>
	float operator*(const Point<T,D>& p, const Vector<T,D>& v);

	template <typename T, size_t D>
	std::ostream& operator<<(std::ostream& out, const Point<T,D>& v);

	template <typename T, size_t D>
	class Point
	{
	public:
		Point()
		{
			for (size_t i = 0; i < D; ++i)
				this->coords[i] = T();
		}

		Point(const T coords[D])
		{
			memcpy(this->coords, coords, D*sizeof(T));
		}

		// copy constructor
		// note that including the custom copy constructor is slightly less efficient vs. the default one (apparently more efficient) generated by the compiler
#ifndef USE_CUSTOM_COPY_CONSTRUCTOR
		// Point(const Point<T, D> &p) = default; // this works only for C++11 and up (explicitly defaulted functions support), but we could just remove the whole copy constructor for older versions
#else
		Point(const Point<T, D> &p) 
		{
			memcpy(this->coords, p.coords, D * sizeof(T));
		}
#endif

		const T& getX() const
		{
			static_assert(D >= 1, POINT_DIMENSION_GETCOORD_FAIL);
			return this->coords[0];
		}

		const T& getY() const
		{
			static_assert(D >= 2, POINT_DIMENSION_GETCOORD_FAIL);
			return this->coords[1];
		}

		const T& getZ() const
		{
			static_assert(D >= 3, POINT_DIMENSION_GETCOORD_FAIL);
			return this->coords[2];
		}

		const T& getW() const
		{
			static_assert(D >= 4, POINT_DIMENSION_GETCOORD_FAIL);
			return this->coords[3];
		}

		float distanceTo(const Point& p)
		{
			return 0;
		}

		T& operator[](unsigned index)
		{
			return this->coords[index];
		}

		T operator[](unsigned index) const
		{
			return this->coords[index];
		}

		Point& operator+=(const Point& v);
		Point& operator+=(const T& val);

		friend bool operator== <>(const Point<T,D>& p1, const Point<T,D>& p2);
		friend Vector<T,D> operator- <>(const Point<T,D>& p1, const Point<T,D>& p2);
		friend Point<T,D> operator+ <>(const Point<T,D>& p, const Vector<T,D>& v);
		friend float operator* <>(const Point<T,D>& p, const Vector<T,D>& v);
		friend std::ostream& operator<< <>(std::ostream& out, const Point<T,D>& v);

		// for backwards compatibility with the older and less generic math classes so as to
		// be able to mix them together (e.g.: add a generic Point3f to a old Vector3d)

		friend Point<T,3> operator+ <>(const Point<T,3>& p, const deprecated::Vector3d& v);
		friend Point<T,3> operator+ <>(const deprecated::Vector3d& v, const Point<T,3>& p);
		friend float operator* <>(const Point<T,3>& p, const deprecated::Vector3d& v);
		friend float operator* <>(const deprecated::Vector3d& v, const Point<T,3>& p);

	protected:
		T coords[D];
	};

	template <typename T>
	class Point1d : public Point<T,1>
	{
	public:
		Point1d() : Point<T,1>() {};

		Point1d(const T& x)
		{
			this->coords[0] = x;
		}
	};

	template <typename T>
	class Point2d : public Point<T,2>
	{
	public:
		Point2d() : Point<T,2>() {};

		Point2d(const T& x, const T& y)
		{
			this->coords[0] = x;
			this->coords[1] = y;
		}
	};

	template <typename T>
	class Point3d : public Point<T,3>
	{
	public:
		Point3d() : Point<T,3>() {};

		Point3d(const T& x, const T& y, const T& z)
		{
			this->coords[0] = x;
			this->coords[1] = y;
			this->coords[2] = z;
		}

		// for backwards compatibility with the deprecated Vector3d

		Point3d(deprecated::Point3d& p)
		{
			this->coords[0] = p.getX();
			this->coords[1] = p.getY();
			this->coords[2] = p.getZ();
		}
	};

	template <typename T>
	class Point4d : public Point<T,4>
	{
	public:
		Point4d() : Point<T,4>() {};
		Point4d(const T& x, const T& y, const T& z, const T&  w)
		{
			this->coords[0] = x;
			this->coords[1] = y;
			this->coords[2] = z;
			this->coords[3] = w;
		}
	};

	typedef Point2d<float> Point2f;
	typedef Point3d<float> Point3f;
	typedef Point4d<float> Point4f;

	typedef Point2d<unsigned> Point2u;
	typedef Point3d<unsigned> Point3u;
	typedef Point4d<unsigned> Point4u;

	typedef Point2d<int> Point2i;
	typedef Point2d<int> Point3i;
	typedef Point2d<int> Point4i;

	//////////////
	// function template definitions for Point<T,D>

	template <typename T, size_t D>
	Point<T,D>& Point<T,D>::operator+=(const Point<T,D>& v)
	{
		for (int i = 0; i < D; i++)
			this->coords[i] += v[i];

		return *this;
	}

	template <typename T, size_t D>
	Point<T,D>& Point<T,D>::operator+=(const T& val)
	{
		for (int i = 0; i < D; i++)
			this->coords[i] += val;

		return *this;
	}

	//////////////
	// friend function template definitions for Point<T,D>

	template <typename T, size_t D>
	bool operator==(const Point<T,D>& p1, const Point<T,D>& p2)
	{
		bool equal = true;
		for (int i=0; i<D && equal; ++i)
		{
			equal = equal && (p1[i] == p2[i]);
		}

		return equal;
	}

	template <typename T, size_t D>
	float operator*(const Point<T,D>& p, const Vector<T,D>& v)
	{
		return v*p;
	}

	template <typename T, size_t D>
	std::ostream& operator<<(std::ostream& out, const Point<T, D>& p)
	{
		out << "(";
		for (int i = 0; i < D; i++)
		{
			out << p.coords[i];
			if (i != D-1) out << ",";
		}
		out << ")";

		return out;
	}

	//////////////
	// friend function template specializations for Point<T,2>

	template <typename T>
	Vector<T,2> operator-(const Point2d<T>& p1, const Point2d<T>& p2)
	{
		return Vector<T,2>(p1.getX()-p2.getX(), p1.getY()-p2.getY());
	}

	template <typename T>
	Point2d<T> operator+(const Point2d<T>& p, const Vector<T,2>& v)
	{
		return Point2d<T>(p.getX()+v.getX(), p.getY()+v.getY());
	}

	//////////////
	// friend function template specializations for Point<T,3>

	template <typename T>
	Vector<T,3> operator-(const Point3d<T>& p1, const Point3d<T>& p2)
	{
		return Vector<T,3>(p1.getX()-p2.getX(), p1.getY()-p2.getY(), p1.getZ()-p2.getZ());
	}

	template <typename T>
	Point3d<T> operator+(const Point3d<T>& p, const Vector<T,3>& v)
	{
		return Point3d<T>(p.getX()+v.getX(), p.getY()+v.getY(), p.getZ()+v.getZ());
	}

	//////////////
	// friend function template definitions for backwards compatibility

	template <typename T>
	Point3d<T> operator+(const Point3d<T>& p, const deprecated::Vector3d& v)
	{
		return Point3d<T>(p.getX()+v.getX(), p.getY()+v.getY(), p.getZ()+v.getZ());
	}

	template <typename T>
	Point3d<T> operator+(const deprecated::Vector3d& v, const Point3d<T>& p)
	{
		return p+v;
	}

	template <typename T>
	float operator*(const deprecated::Vector3d& v, const Point3d<T>& p)
	{
		return v.getX()*p.getX() + v.getY()*p.getY() + v.getZ()*p.getZ();
	}

	template <typename T>
	float operator*(const Point3d<T>& p, const deprecated::Vector3d& v)
	{
		return v*p;
	}

	#undef USE_CUSTOM_COPY_CONSTRUCTOR
	#undef POINT_DIMENSION_CONSTRUCTOR_FAIL
	#undef POINT_DIMENSION_GETCOORD_FAIL
}}

#endif
